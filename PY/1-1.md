# 문자열
### 공백 제거
- strip() : 양쪽의 공백 제거
- lstrip() : 왼쪽의 공백 제거
- rstrip() : 오른쪽의 공백 제거
- 위의 각 메서드에 "문자"를 넣으면 공백대신 특정 "문자"를 제거함

### 문자 찾기
- find("문자") : 특정 "문자"가 **왼쪽을 기준으로 몇 번쨰에 있는지** 찾기
    - 존재하지 않는 경우 **-1** 반환
- rfind("문자") : 특정 "문자"가 **오른쪽을 기준으로 몇 번쨰에 있는지** 찾기

# Built in type
- List,Tuple,Dictionary,Set 등 파이썬에서 기본으로 제공하는 자료구조

### List
- 여러 원소를 담은 데이터 타입
- \[\] 또는 list()를 사용하여 선언 가능
- 원소 추가 
    - 맨 뒤 : **append('문자')**
    - 특정 위치 : **insert(idx,'문자')**
- 슬라이싱
    - 인덱스 a~b-1까지의 원소를 가져오고 싶다 : **리스트\[a:b-1\]**
    - 첫번째 원소(idx:0) 생략 가능, 마지막 원소 : -1 

### Tuple
- 리스트와 마찬가지로 여러 값을 하나로 묶는 데이터 타입 (원소가 상수여야 하고, 수정 불가)
- \(\)를 사용하거나 마지막 값 뒤에 ,표시
    - ```python
        a = (1,2,3)
        a = 1,2,3,
        ```
### Dictionary
- Map 타입의 자료구조 (Key-Value)
- \{\} 또는 dict()로 선언 가능
- 값 추가
    - ```a[새로운 키] = value```
- 값 수정
    - ```a[기존 키]=value```
- 값 제거
    - ```del a[기존 키]```
    - ```a.pop[기존 키]```
- 키 확인
    - ```'확인하고싶은 키' in a ```
- 값 불러오기
    1. ```a[가져올 키]```
        - 없으면 KeyError
    2. ```a.get(가져올 키)```
        - 없으면 None반환
        - 없을 시, 불러올 값 지정 가능
- zip함수를 사용하면 2개의 리스트를 각 키, 값으로 할당하여 딕셔너리로 선언 가능
    - ```c = dict(zip(['key1','key2'],[1,2]))```

### 집합
- 중복을 허용하지 않는 원소 모음
    - 집합 선언 시, 중복 값을 모두 제거하고 저장함
- {},set()으로 선언 가능
- in, not in 으로 포함여부 확인 가능
- 집합 단위 연산
    - 합집합(union) : |
        - ``` a|b ```
        - ``` set.union(a,b)```
    - 교집합(intersection) : &
        - ```a&b```
        - ```set.intersection(a,b)```
    - 차집합(subtract) : -
        - ```a-b```
        - ```set.difference(a,b)```
    - 배타적논리합(exclusive) :^
        - ```a^b```
        - ```set.symmetric_difference(a,b)```

# 함수와 람다표현식
### 함수
- def로 함수 선언
### 람다
- 파이썬의 익명함수
```python
    func = lambda p : p + 10
    func(1) # 결과 11
```
```python
(lambda p : p + 10)(1) # 바로 사용하기
```
- Lambda함수 응용 (map, filter와 함께 사용)
    - map
        ```python
        list(map(lambda p: p+10,[1,2,3])) #결과 [2,3,4]
        ```
    - filter
        ```python
        list(filter(lambda p: p%2,[2,3,4,5])) #결과 [3,5]
        ```
# 고급 제어
### 반복자
- Class를 반복 가능한 객체로 만들어 Iterator(반복자)로 사용할 수 있음
- 방법
    - Class정의 시, 아래의 두가지 메서드 구현
        1. __iter__
        2. __next__
- 예시
    ```python
    class TestIter:
        def __init__(self,n):
            self.n = n
            self.i = 0
        def __iter__(self):
            return self
        def __next__(self):
            if self.i >= self.n :
                raise StopIteration
            res = self.i
            self.i += 1
            return res
    
    for i in TestIter(3):
        print(i)
    ```
- Iterator로 만든 객체를 iter객체로 만들어 next()로 이용할 수도 있음
    - ```python
        itr = iter(TestIter(3))
        print(next(itr,-1))
        print(next(itr,-1))
        print(next(itr,-1))
        print(next(itr,-1)) #더이상 반복할 곳이 없으면 -1을 반환하도록 하는 것
        ```

### 제너레이터
- yield 키워드를 사용하여 호출자에 값을 전달하는 객체

### 데코레이터
- 디자인 패턴에서 기능을 덧붙이는 것
- 함수에 기능 추가 가능 
- 예시
    ```python
    def print_time(func):
        def wrapper(n):
            stime = time.time()
            res = func(n)
            print('elapse time: {} sec'.format(time.time()-stime))
            return res
        return wrapper
    ```
- 코루틴
    - 